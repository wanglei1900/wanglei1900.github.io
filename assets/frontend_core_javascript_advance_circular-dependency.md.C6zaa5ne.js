import{_ as t,C as l,c as p,o as i,a7 as a,b as r,w as n,a as h,G as k,a8 as o}from"./chunks/framework.Dtft01Yp.js";const y=JSON.parse('{"title":"🧿 前端中循环依赖","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/core/javascript/advance/circular-dependency.md","filePath":"frontend/core/javascript/advance/circular-dependency.md","lastUpdated":1751966758000}'),d={name:"frontend/core/javascript/advance/circular-dependency.md"};function c(E,s,u,g,m,b){const e=l("Mermaid");return i(),p("div",null,[s[1]||(s[1]=a(`<h1 id="🧿-前端中循环依赖" tabindex="-1">🧿 前端中循环依赖 <a class="header-anchor" href="#🧿-前端中循环依赖" aria-label="Permalink to &quot;🧿 前端中循环依赖&quot;">​</a></h1><blockquote><p>什么是循环依赖: 两个以上模块之间互相引用，构成闭环依赖。</p></blockquote><p><strong>保持依赖引入的单向流通性！</strong></p><p>示例： 不要觉得自己不会写出这样的代码，当项目庞大后一旦出现这样的问题将会造成无法排查的问题。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在a.js 引用 b.js 内容</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {b} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./b.js&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  omit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在b.js 引用 a.js 内容</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {a} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./a.js&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  omit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="🎯-一、-为什么循环依赖会造成报错" tabindex="-1">🎯 一、 为什么循环依赖会造成报错 <a class="header-anchor" href="#🎯-一、-为什么循环依赖会造成报错" aria-label="Permalink to &quot;🎯 一、 为什么循环依赖会造成报错&quot;">​</a></h2><blockquote><p>循环依赖产生之后报错的原因，通常是由模块执行顺序造成的。</p></blockquote><h3 id="_1-执行顺序" tabindex="-1">1. 执行顺序 <a class="header-anchor" href="#_1-执行顺序" aria-label="Permalink to &quot;1. 执行顺序&quot;">​</a></h3><p>执行的顺序导致的模块先后加载时，出现未定义未初始化的报错。</p><ul><li>ES6 modules 在ES6模块中，模块的加载顺序是由它们在代码中的出现顺序决定的。因此，如果两个模块相互引用，那么先出现的模块将先执行。</li><li>CommonJS 在CommonJS模块中，模块的加载顺序是由require函数的调用顺序决定的。因此，如果两个模块相互引用，那么先调用require函数的模块将先执行。</li></ul><h3 id="_2-es6-和-commonjs-输出的值是和原始值是什么关系-修改导出的值是否会影响原始值" tabindex="-1">2. ES6 和 CommonJS 输出的值是和原始值是什么关系？（修改导出的值是否会影响原始值） <a class="header-anchor" href="#_2-es6-和-commonjs-输出的值是和原始值是什么关系-修改导出的值是否会影响原始值" aria-label="Permalink to &quot;2. ES6 和 CommonJS 输出的值是和原始值是什么关系？（修改导出的值是否会影响原始值）&quot;">​</a></h3><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 -- 《ECMAScript 6 入门教程》</p><ul><li><p>CommonJS 模块确实输出的是一个值的拷贝。当你使用 module.exports 导出一个值时，这个值是被复制的，而不是被引用的。这意味着，如果你导出一个对象，那么对这个对象的修改不会影响到其他模块。</p></li><li><p>ES6模块使用 export 关键字来导出值，并且默认情况下，这些值是被引用的，而不是被复制的。这意味着，如果你导出一个对象，那么对这个对象的修改会影响到其他模块。但是，有一种情况下，ES6模块会创建一个值的拷贝，那就是当你使用 export 导出一个函数或者类的时候。在这种情况下，函数或者类的代码会被复制，但是任何在函数或者类中引用的外部变量仍然会被引用。</p></li></ul><br><h2 id="🧱-二、-实际案例" tabindex="-1">🧱 二、 实际案例 <a class="header-anchor" href="#🧱-二、-实际案例" aria-label="Permalink to &quot;🧱 二、 实际案例&quot;">​</a></h2><p>假设现在你有一个 <code>redux/store.ts</code> 文件 和 <code>api/http.ts</code> 文件，分别为store仓库和axios请求。你需要在http文件中触发redux，来触发token的设置和清除，这是再正常不过的一个操作了吧。</p><ul><li><p>http.ts 文件引入store，并视图通过store实例身上的方法修改state（通常是token）</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> axios </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;axios&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@/redux/store&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">omit</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>目前的依赖关系 http.ts =&gt; store.ts</p></li><li><p>实际的请求文件login.ts，引入http.ts 暴露的axios</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> http </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@/api&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">omit</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>目前的依赖关系 login.ts =&gt; http.ts</p></li><li><p>store 下某个切片文件 authSlice.ts 引用了login.ts里的请求</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { getAuthButtonListApi, getAuthMenuListApi } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@/api/modules/login&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>目前的依赖关系 authSlice.ts =&gt; login.ts</p></li><li><p>由于authSlice 会被并入store</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { combineReducers } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@reduxjs/toolkit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> authReducer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./authSlice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> combineReducers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  auth: authReducer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>目前的依赖关系 ， store.ts =&gt; authSlice.ts</p></li></ul><p>最终的依赖关系变为 <strong>store.ts =&gt; authSlice.ts =&gt; login.ts =&gt; http.ts =&gt; store.ts</strong>，最终居然形成了循环依赖！</p>`,18)),(i(),r(o,null,{default:n(()=>[k(e,{id:"mermaid-107",class:"mermaid",graph:"flowchart%20TB%0A%20%20A%5Bstore.ts%5D%20--%3E%20B%5BauthSlice.ts%5D%0A%20%20B%20--%3E%20C%5Blogin.ts%5D%0A%20%20C%20--%3E%20D%5Bhttp.ts%5D%0A%20%20D%20e1%40%20--%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%20--%3E%20A%5Bstore.ts%5D%0A%0A%20%20%25%25%20%E6%96%B9%E5%9D%97%0A%20%20classDef%20block%20fill%3A%23ffe6e6%2Cstroke%3A%23ff0000%2Cstroke-width%3A3px%3B%0A%20%20class%20A%2CB%2CC%2CD%20block%3B%0A%20%20%0A%20%20%25%25%20%E5%8A%A8%E7%94%BB%0A%20%20linkStyle%203%20stroke%3A%23ff0000%2Cstroke-width%3A4px%2Ccolor%3Ared%3B%0A%20%20e1%40%7B%20animation%3A%20fast%20%7D%0A%0A%20%20%25%25%20%E6%B7%BB%E5%8A%A0%E8%AF%B4%E6%98%8E%E6%96%87%E6%9C%AC%0A%20%20T(%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%B7%AF%E5%BE%84)%3A%3A%3Anote%0A%20%20classDef%20note%20fill%3A%23f9f9f9%2Cstroke%3A%23ccc%3B%0A%20%20class%20T%20note%3B%0A%20%20style%20T%20fill%3A%23f9f9f9%2Cstroke-dasharray%3A%205%205%0A"})]),fallback:n(()=>s[0]||(s[0]=[h(" Loading... ")])),_:1})),s[2]||(s[2]=a('<br><h2 id="🎲-三、-项目如何避免循环引用" tabindex="-1">🎲 三、 项目如何避免循环引用 <a class="header-anchor" href="#🎲-三、-项目如何避免循环引用" aria-label="Permalink to &quot;🎲 三、 项目如何避免循环引用&quot;">​</a></h2><p>本质上如何避免循环引用，就是用监测手段 循环引用 并及时切断。</p><h3 id="_1-集成在webpack等脚手架的循环依赖分析" tabindex="-1">1. 集成在webpack等脚手架的循环依赖分析 <a class="header-anchor" href="#_1-集成在webpack等脚手架的循环依赖分析" aria-label="Permalink to &quot;1. 集成在webpack等脚手架的循环依赖分析&quot;">​</a></h3><p>webpack插件名字 <code>circular-dependency-plugin</code></p><h3 id="_2-集成在eslint的循环依赖分析" tabindex="-1">2. 集成在EsLint的循环依赖分析 <a class="header-anchor" href="#_2-集成在eslint的循环依赖分析" aria-label="Permalink to &quot;2. 集成在EsLint的循环依赖分析&quot;">​</a></h3><p>EsLint插件名字 <code>eslint-plugin-import</code> ，eslint 规则 import/no-cycle</p><h3 id="_3-dpdm-开源插件" tabindex="-1">3. dpdm 开源插件 <a class="header-anchor" href="#_3-dpdm-开源插件" aria-label="Permalink to &quot;3. dpdm 开源插件&quot;">​</a></h3><p>插件名字 <code>dpdm</code> 使用 dpdm 定位 JavaScript/TypeScript 中的循环依赖</p><h3 id="_4-ts项目类型" tabindex="-1">4. TS项目类型 <a class="header-anchor" href="#_4-ts项目类型" aria-label="Permalink to &quot;4. TS项目类型&quot;">​</a></h3><p>使用 <code>import type {} from &#39;./xxx&#39;</code> 模块的类型定义，而不导入实际的模块内容。而不加type则会类型和实际值都被导入</p>',11))])}const F=t(d,[["render",c]]);export{y as __pageData,F as default};
