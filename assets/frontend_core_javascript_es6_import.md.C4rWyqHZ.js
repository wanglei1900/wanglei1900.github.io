import{_ as t,c as r,o as a,a7 as e}from"./chunks/framework.Dtft01Yp.js";const f=JSON.parse('{"title":"ES6 暴露模块及导入注意事项","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/core/javascript/es6/import.md","filePath":"frontend/core/javascript/es6/import.md","lastUpdated":1751966758000}'),p={name:"frontend/core/javascript/es6/import.md"};function x(i,o,s,m,l,n){return a(),r("div",null,o[0]||(o[0]=[e('<h1 id="es6-暴露模块及导入注意事项" tabindex="-1">ES6 暴露模块及导入注意事项 <a class="header-anchor" href="#es6-暴露模块及导入注意事项" aria-label="Permalink to &quot;ES6 暴露模块及导入注意事项&quot;">​</a></h1><h2 id="基础" tabindex="-1">基础 <a class="header-anchor" href="#基础" aria-label="Permalink to &quot;基础&quot;">​</a></h2><p>export与export default均可用于导出常量、函数、文件、模块等</p><p>在一个文件或模块中，export、import可以有多个，export default仅有一个</p><p>如果一个文件里export了很多函数（常量,变量）， 如果你想在目标一次性全部导入模块的所有函数（常量,变量）就可以使用 import * as xxx代表全部</p><p>通过export方式导出，在导入时要加{ }（因为export方式需要一一对应，本质上使用了解构），而export default则不需要</p><p>export能直接导出变量表达式，export default不行。</p><h2 id="我的混淆点" tabindex="-1">我的混淆点 <a class="header-anchor" href="#我的混淆点" aria-label="Permalink to &quot;我的混淆点&quot;">​</a></h2><ol><li>import * as obj from &#39;xxx&#39;,与 import from 的区别 export参数指定单个（多个）的命名导出，import {foo,bar} from &quot;xxx&quot;，一一对应的引入foo，bar</li></ol><p>export参数指定多个的命名导出，而import * as name语法导入所有导出接口，即导入模块整体。</p><p>如何理解 import * as obj from &quot;xxx&quot; 会将 &quot;xxx&quot; 中所有 export 导出的内容组合成一个模块（对象obj）返回。若模块中包含一个一个接口getList()，则调用时需写obj.getList()</p><ol start="2"><li><p>import * as obj from &#39;xxx&#39; 与 import {a as obj} from &#39;xxx&#39; 如何理解 import {a as obj} from &#39;xxx&#39;，这里是将 a 引入的同时重命名为obj。</p></li><li><p>import &quot;xxx&quot; 与 import {foo} from &quot;xxx&quot; 如何理解 import &quot;xxx&quot; 仅仅执行xxx里的代码，而不输入任何值（还不了解具体使用场景为什么要这么写）</p></li></ol>',12)]))}const u=t(p,[["render",x]]);export{f as __pageData,u as default};
