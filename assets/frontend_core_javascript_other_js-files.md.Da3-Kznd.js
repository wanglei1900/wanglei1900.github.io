import{_ as e,c as i,o as r,a7 as o}from"./chunks/framework.Dtft01Yp.js";const c=JSON.parse('{"title":"今天在修改公司ui组件库的时候，接触到npm run lib ，发现打包后文件有几种格式的文件。","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/core/javascript/other/js-files.md","filePath":"frontend/core/javascript/other/js-files.md","lastUpdated":1751966758000}'),s={name:"frontend/core/javascript/other/js-files.md"};function p(l,a,n,t,m,d){return r(),i("div",null,a[0]||(a[0]=[o('<h1 id="今天在修改公司ui组件库的时候-接触到npm-run-lib-发现打包后文件有几种格式的文件。" tabindex="-1">今天在修改公司ui组件库的时候，接触到npm run lib ，发现打包后文件有几种格式的文件。 <a class="header-anchor" href="#今天在修改公司ui组件库的时候-接触到npm-run-lib-发现打包后文件有几种格式的文件。" aria-label="Permalink to &quot;今天在修改公司ui组件库的时候，接触到npm run lib ，发现打包后文件有几种格式的文件。&quot;">​</a></h1><p><code>.common.js .common.js.map</code></p><p><code>.umd.js .umd.js.map .umd.min.js .umd.min.js.map</code></p><h2 id="一、几种不同的模块化方案" tabindex="-1">一、几种不同的模块化方案 <a class="header-anchor" href="#一、几种不同的模块化方案" aria-label="Permalink to &quot;一、几种不同的模块化方案&quot;">​</a></h2><ul><li><p>CommonJS是一种被广泛使用的node.js模块化规范，核心思想是通过require方法来同步加载依赖的其他模块，通过module.exports导出需要暴露的接口。优点---Node.js 环境下井运行</p></li><li><p>AMD 就是 RequireJS 在推广过程中对模块定义的规范化产出用于浏览器端的问题，使用 RequireJS 加载模块化脚本能提高代码的加载速度和质量。优点----依赖前置、提前执行</p></li><li><p>CMD 是 Sea.js 在推广过程中对模块定义的规范化产出。Sea.js 是阿里的玉伯写的。优点----依赖就近、延迟执行</p></li><li><p>UMD是当CommonJS、AMD、CMD在并行的状态时，就需要一种方案能够兼容他们，这样我们在开发时，就不需要再去考虑依赖模块所遵循的规范了，UMD的出现就是为了解决这个问题。优点---解决CommonJS,AMD,CMD无法兼容的问题。</p></li><li><p>ES6 Module 的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及导入和导出的变量，也就是所谓的&quot;编译时加载&quot;。---目前使用最多，最优秀</p></li></ul><h2 id="二、区别" tabindex="-1">二、区别 <a class="header-anchor" href="#二、区别" aria-label="Permalink to &quot;二、区别&quot;">​</a></h2><p><em>CommonJS 是服务于服务端的，而其他的是服务于浏览器端的。</em></p><h3 id="min-js" tabindex="-1">min.js <a class="header-anchor" href="#min-js" aria-label="Permalink to &quot;min.js&quot;">​</a></h3><p>min.js为压缩的文件，压缩代码减小体积加快传输速度，另外可以替换混淆变量增加代码安全性。</p><p><a href="./../library/uglify">🚀 手动压缩一个js文件为min.js</a></p><h3 id="js-map" tabindex="-1">js.map <a class="header-anchor" href="#js-map" aria-label="Permalink to &quot;js.map&quot;">​</a></h3><p>.map文件为用来调试min.js文件，有了map就可以像未加密的代码一样，准确的输出是哪一行哪一列有错。</p><h2 id="三、webpack打包时去除js-map文件" tabindex="-1">三、webpack打包时去除js.map文件 <a class="header-anchor" href="#三、webpack打包时去除js-map文件" aria-label="Permalink to &quot;三、webpack打包时去除js.map文件&quot;">​</a></h2><h3 id="_1-问题" tabindex="-1">1.问题 <a class="header-anchor" href="#_1-问题" aria-label="Permalink to &quot;1.问题&quot;">​</a></h3><p>项目准备上线时，webpack打包时，生成的map文件很大，map文件功能如下，体积会变得臃肿</p><p>Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。</p><p>有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。</p><h3 id="_2-解决办法" tabindex="-1">2.解决办法 <a class="header-anchor" href="#_2-解决办法" aria-label="Permalink to &quot;2.解决办法&quot;">​</a></h3><p>修改sourceMap配置成为false。</p><ul><li>配置文件vue.config.js 中 productionSourceMap:false</li><li>npm run build打包出来后js跟css中已经没有map文件</li></ul>',20)]))}const h=e(s,[["render",p]]);export{c as __pageData,h as default};
